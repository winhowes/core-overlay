<!--
    @license
    Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="core-overlay-layer.html">
<link rel="import" href="constrain-size.html">
<link rel="import" href="events-helper.html">
<link rel="import" href="overlay-manager.html">

<!--
The `core-overlay` element displays overlayed on top of other content. It starts
out hidden and is displayed by setting its `opened` property to true.
A `core-overlay's` opened state can be toggled by calling the `toggle`
method.

The `core-overlay` will, by default, show/hide itself when it's opened. The
`target` property may be set to another element to cause that element to
be shown when the overlay is opened.

It's common to want a `core-overlay` to animate to its opened
position. The `core-overlay` element uses a `core-transition` to handle
animation. The default transition is `core-transition-fade` which
causes the overlay to fade in when displayed. See
<a href="../core-transition/">`core-transition`</a> for more
information about customizing a `core-overlay's` opening animation. The
`backdrop` property can be set to true to show a backdrop behind the overlay
that will darken the rest of the window.

An element that should close the `core-overlay` will automatically
do so if it's given the `core-overlay-toggle` attribute. This attribute
can be customized with the `closeAttribute` property. You can also use
`closeSelector` if more general matching is needed.

By default  `core-overlay` will close whenever the user taps outside it or
presses the escape key. This behavior can be turned off via the
`autoCloseDisabled` property.

    <core-overlay>
      <h2>Dialog</h2>
      <input placeholder="say something..." autofocus>
      <div>I agree with this wholeheartedly.</div>
      <button core-overlay-toggle>OK</button>
    </core-overlay>

`core-overlay` will automatically size and position itself according to the
following rules. The overlay's size is constrained such that it does not
overflow the screen. This is done by setting maxHeight/maxWidth on the
`sizingTarget`. If the `sizingTarget` already has a setting for one of these
properties, it will not be overridden. The overlay should
be positioned via css or imperatively using the `core-overlay-position` event.
If the overlay is not positioned vertically via setting `top` or `bottom`, it
will be centered vertically. The same is true horizontally via a setting to
`left` or `right`. In addition, css `margin` can be used to provide some space
around the overlay. This can be used to ensure
that, for example, a drop shadow is always visible around the overlay.

@group Core Elements
@element core-overlay
@mixins Polymer.CoreResizer https://github.com/polymer/core-resizable
@homepage github.io
-->
<!--
Fired when the `core-overlay`'s `opened` property changes.

@event core-overlay-open
@param {Object} detail
@param {Object} detail.opened the opened state
-->
<!--
Fired when the `core-overlay` has completely opened.

@event core-overlay-open-completed
-->
<!--
Fired when the `core-overlay` has completely closed.

@event core-overlay-close-completed
-->
<!--
Fired when the `core-overlay` needs to position itself. Optionally, implement
in order to position an overlay via code. If the overlay was not otherwise
positioned, it's important to indicate how the overlay has been positioned by
setting the `dimensions.position` object. For example, if the overlay has been
positioned via setting `right` and `top`, set dimensions.position to an
object like this: `{v: 'top', h: 'right'}`.

@event core-overlay-position
@param {Object} detail
@param {Object} detail.target the overlay target
@param {Object} detail.sizingTarget the overlay sizing target
@param {Object} detail.opened the opened state
-->

<!--
Fired when the user cancels the `core-overlay`.

@event core-overlay-cancel
@param {Object} detail
@param {Object} detail.target the overlay target
-->

<dom-module id="core-overlay">

  <style>
    core-overlay {
      background: #fff;
    }

    .core-overlay-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: black;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .core-overlay-backdrop.core-opened {
      opacity: 0.6;
    }
  </style>

</dom-module>

<script>

  using(['overlay-manager'], function(manager) {

    Polymer({

      is: 'core-overlay',

      mixins: [
        'constrain-size',
        'events-helper'
      ],

      published: {
        /**
         * The target element that will be shown when the overlay is
         * opened. If unspecified, the core-overlay itself is the target.
         *
         * @attribute target
         * @type Object
         * @default the overlay element
         */
        target: Object,

        /**
         * A `core-overlay`'s size is guaranteed to be
         * constrained to the window size. To achieve this, the sizingElement
         * is sized with a max-height/width. By default this element is the
         * target element, but it can be specifically set to a specific element
         * inside the target if that is more appropriate. This is useful, for
         * example, when a region inside the overlay should scroll if needed.
         *
         * @attribute sizingTarget
         * @type Object
         * @default the target element
         */
        sizingTarget: Object,

        /**
         * Set opened to true to show an overlay and to false to hide it.
         * A `core-overlay` may be made initially opened by setting its
         * `opened` attribute.
         * @attribute opened
         * @type boolean
         * @default false
         */
        opened: Boolean,

        /**
         * If true, the overlay has a backdrop darkening the rest of the screen.
         * The backdrop element is attached to the document body and may be styled
         * with the class `core-overlay-backdrop`. When opened the `core-opened`
         * class is applied.
         *
         * @attribute backdrop
         * @type boolean
         * @default false
         */
        backdrop: Boolean,

        /**
         * If true, the overlay is guaranteed to display above page content.
         *
         * @attribute layered
         * @type boolean
         * @default false
        */
        layered: Boolean,

        closeonevent: String,

        cancelonexternalevent: String,

        cancelkeycode: Number,

        /**
         * This property specifies an event that should close the overlay.
         *
         * @attribute closeEvent
         * @type String
         * @default "tap"
         */
        closeevent: String,

        /**
         * This property specifies an attribute on elements that should
         * close the overlay on tap. Should not set `closeSelector` if this
         * is set.
         *
         * @attribute closeAttribute
         * @type string
         * @default "core-overlay-toggle"
         */
        closeattribute: String,

        /**
         * This property specifies a selector matching elements that should
         * close the overlay on tap. Should not set `closeAttribute` if this
         * is set.
         *
         * @attribute closeSelector
         * @type string
         * @default ""
         */
        closeselector: String,

        /**
         * By default an overlay will close automatically if the user
         * taps outside it or presses the escape key. Disable this
         * behavior by setting the `autoCloseDisabled` property to true.
         * @attribute autoCloseDisabled
         * @type boolean
         * @default false
         */
        // autoCloseDisabled: Boolean,

        /**
         * By default an overlay will focus its target or an element inside
         * it with the `autoFocus` attribute. Disable this
         * behavior by setting the `autoFocusDisabled` property to true.
         * @attribute autoFocusDisabled
         * @type boolean
         * @default false
         */
        // autoFocusDisabled: Boolean,

        /**
         * The transition property specifies a string which identifies a
         * <a href="../core-transition/">`core-transition`</a> element that
         * will be used to help the overlay open and close. The default
         * `core-transition-fade` will cause the overlay to fade in and out.
         *
         * @attribute transition
         * @type string
         * @default 'core-transition-fade'
         */
        transition: String

      },

      bind: {
        opened: 'openedChanged'
      },

      attached: function() {
        // this.resizerAttachedHandler();
      },

      detached: function() {
        // this.resizerDetachedHandler();
      },

      resizerShouldNotify: function() {
        return this.opened;
      },

      get targetListeners() {
        var listeners = {
          'keydown': 'onKeydown',
        };
        listeners['click'] = 'onCloseEvent';
        return listeners;
      },

      configure: function() {
        var backdropEl = document.createElement('div');
        backdropEl.className = 'core-overlay-backdrop';

        return {
          opened: false,
          backdrop: false,
          backdropEl: backdropEl,
          layered: false,
          closeonevent: false,
          cancelonesckey: true,
          cancelonexternalevent: 'click',
          cancelkeycode: this.eventKeyCodes.ESC_KEY,
          closeevent: 'mousedown',
          closeattribute: 'core-overlay-toggle',
          closeselector: '',
          target: this,
          sizingTarget: this.target || this,
          transition: 'core-transition-fade'
        }
      },

      ready: function() {
        this.async(function() {
          this.ensureTargetSetup();
        }, 10);
      },

      /**
       * Toggle the opened state of the overlay.
       * @method toggle
       */
      toggle: function() {
        this.opened = !this.opened;
      },

      /**
       * Open the overlay. This is equivalent to setting the `opened`
       * property to true.
       * @method open
       */
      open: function() {
        this.opened = true;
      },

      /**
       * Close the overlay. This is equivalent to setting the `opened`
       * property to false.
       * @method close
       */
      close: function() {
        this.opened = false;
      },

      /**
       * Cancels the overlay.
       * @method cancel
       */
      cancel: function() {
        this.opened = false,
        this.fire('core-overlay-cancel', {target: this.target});
      },

      /*
      targetChanged: function(old) {
        if (this.target) {
          // really make sure tabIndex is set
          if (this.target.tabIndex < 0) {
            this.target.tabIndex = -1;
          }
          this.addElementListenerList(this.target, this.targetListeners);
          this.target.style.display = 'none';
          this.target.__overlaySetup = false;
        }
        if (old) {
          this.removeElementListenerList(old, this.targetListeners);
          var transition = this.getTransition();
          if (transition) {
            transition.teardown(old);
          } else {
            old.style.position = '';
            old.style.outline = '';
          }
          old.style.display = '';
        }
      },
      */

      /*
      transitionChanged: function(old) {
        if (!this.target) {
          return;
        }
        if (old) {
          var transition = this.getTransition(old);
          if (transition) {
            transition.teardown(this.target);
          }
        }
        this.target.__overlaySetup = false;
      },
      */

      // NOTE: wait to call this until we're as sure as possible that target
      // is styled.
      ensureTargetSetup: function() {
        if (!this.target || this.target.__overlaySetup) {
          return;
        }
        this.target.__overlaySetup = true;
        this.target.style.display = '';
        var transition = this.getTransition();
        if (transition) {
          transition.setup(this.target);
        }
        var style = this.target.style;
        var computed = getComputedStyle(this.target);
        if (computed.position === 'static') {
          style.position = 'fixed';
        }
        style.outline = 'none';
        style.display = 'none';
        // installing listeners here means target events cannot be configured after ready()
        this.addElementListenerList(this.target, this.targetListeners);
      },

      openedChanged: function() {
        this.transitioning = true;
        this.ensureTargetSetup();
        this.prepareRenderOpened();
        // async here to allow overlay layer to become visible.
        this.async(function() {
          this.target.style.display = '';
          // force layout to ensure transitions will go
          this.target.offsetWidth;
          this.renderOpened();
        });
        this.fire('core-overlay-open', this.opened);
      },

      // tasks which must occur before opening; e.g. making the element visible
      prepareRenderOpened: function() {
        if (this.opened) {
          manager.addOverlay(this);
        }
        this.prepareBackdrop();
        // async so we don't auto-close immediately via a click.
        this.async(function() {
          if (this.cancelonexternalevent) {
            this.enableElementListener(this.opened, document,
                this.cancelonexternalevent, 'onCaptureEvent', true);
          }
        });
        this.enableElementListener(this.opened, window, 'resize',
            'resizeHandler');

        if (this.opened) {
          // force layout so SD Polyfill renders
          this.target.offsetHeight;
          this.discoverDimensions();
          // if we are showing, then take care when positioning
          this.preparePositioning();
          this.positionTarget();
          this.updateTargetDimensions();
          this.finishPositioning();
          // if (this.layered) {
          //   this.layer.addElement(this.target);
          //   this.layer.opened = this.opened;
          // }
        }
      },

      // tasks which cause the overlay to actually open; typically play an
      // animation
      renderOpened: function() {
        // this.notifyResize();
        var transition = this.getTransition();
        if (transition) {
          transition.go(this.target, {opened: this.opened});
        } else {
          this.transitionend();
        }
        this.renderBackdropOpened();
      },

      // finishing tasks; typically called via a transition
      transitionend: function(e) {
        // make sure this is our transition event.
        if (e && e.target !== this.target) {
          return;
        }
        this.transitioning = false;
        if (!this.opened) {
          this.resetTargetDimensions();
          this.target.style.display = 'none';
          this.completeBackdrop();
          manager.removeOverlay(this);
          // if (this.layered) {
          //   if (!currentOverlay()) {
          //     this.layer.opened = this.opened;
          //   }
          //   this.layer.removeElement(this.target);
          // }
        }
        this.fire('core-overlay-' + (this.opened ? 'open' : 'close') +
            '-completed');
        this.applyFocus();
      },

      prepareBackdrop: function() {
        if (this.backdrop && this.opened) {
          if (!this.backdropEl.parentNode) {
            document.body.appendChild(this.backdropEl);
            this.backdropEl.style.zIndex = currentOverlayZ() - 1;
          }
          manager.trackBackdrop(this);
        }
      },

      renderBackdropOpened: function() {
        if (this.backdrop && manager.getBackdrops().length < 2) {
          this.backdropEl.classList.toggle('core-opened', this.opened);
        }
      },

      completeBackdrop: function() {
        if (this.backdrop) {
          manager.trackBackdrop(this);
          if (manager.getBackdrops().length === 0) {
            this.backdropEl.parentNode.removeChild(this.backdropEl);
          }
        }
      },

      preparePositioning: function() {
        this.target.style.transition = this.target.style.webkitTransition = 'none';
        this.target.style.transform = this.target.style.webkitTransform = 'none';
        this.target.style.display = '';
      },

      finishPositioning: function(target) {
        this.target.style.display = 'none';
        this.target.style.transform = this.target.style.webkitTransform = '';
        // force layout to avoid application of transform
        this.target.offsetWidth;
        this.target.style.transition = this.target.style.webkitTransition = '';
      },

      getTransition: function(name) {
        // return this.meta.byId(name || this.transition);
      },

      getFocusNode: function() {
        return this.target.querySelector('[autofocus]') || this.target;
      },

      applyFocus: function() {
        var focusNode = this.getFocusNode();
        if (this.opened) {
          if (!this.autoFocusDisabled) {
            focusNode.focus();
          }
        } else {
          focusNode.blur();
          if (manager.currentOverlay() == this) {
            console.warn('Current core-overlay is attempting to focus itself as next! (bug)');
          } else {
            manager.focusOverlay();
          }
        }
      },

      onCloseEvent: function(e) {
        console.log('onCloseEvent', e);
        // closeSelector takes precedence since closeAttribute has a default non-null value.
        if (e.target &&
            (this.closeselector && e.target.matches(this.closeselector)) ||
            (this.closeattribute && e.target.hasAttribute(this.closeattribute))) {
          this.toggle();
        } else {
          if (this.cancelJob) {
            this.cancelAsync(this.cancelJob);
            this.cancelJob = null;
          }
        }
      },

      // We use the traditional approach of capturing events on document
      // to to determine if the overlay needs to close. However, due to
      // ShadowDOM event retargeting, the event target is not useful. Instead
      // of using it, we attempt to close asynchronously and prevent the close
      // if a tap event is immediately heard on the target.
      // TODO(sorvell): This approach will not work with modal. For
      // this we need a scrim.
      onCaptureEvent: function(e) {
        if (this.cancelonexternalevent && (manager.currentOverlay() == this)) {
          this.cancelJob = this.async(function() {
            this.cancel();
          }, 10);
        }
      },

      onKeydown: function(e) {
        if (this.cancelonesckey && (e.keyCode === this.cancelkeycode)) {
          this.cancel();
          e.stopPropagation();
        }
      },

      /**
       * Extensions of core-overlay should implement the `resizeHandler`
       * method to adjust the size and position of the overlay when the
       * browser window resizes.
       * @method resizeHandler
       */
      resizeHandler: function() {
        this.updateTargetDimensions();
      }

    });

  });

</script>
